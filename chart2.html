<!DOCTYPE html>
<meta charset="utf-8">


<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/vue.min.js"></script>


<canvas id="histogram" width="450" height="250" style="border: 1px solid red"></canvas>

<canvas id="chart" width="450" height="250" style="border: 1px solid red"></canvas>

<canvas id="canvas" width="150" height="150"></canvas>
<script>

function random_data(num_sims, pts_per_sim){
  return _.range(num_sims).map(function(){
    return {
      "pts": _.range(pts_per_sim).map(_ => Math.random()),
      "european": Math.random(),
      "asian": Math.random()
    }; 
  });
}
random_data(100, 200);

function getPosition(elapsed_ms, num_sims, pts_per_sim){

  /* Return the max position we can animate upto */
  const ms_per_pt = 1;
  const ms_per_sim = ms_per_pt * pts_per_sim;

  const sim_ind = Math.floor(elapsed_ms / ms_per_sim);
  const ms_into_sim = elapsed_ms - sim_ind * ms_per_sim;
  const pt_ind = Math.floor(ms_into_sim / ms_per_pt); 

  return {sim_ind: sim_ind, pt_ind: pt_ind};
}

function start_animation(){
  const num_sims = 100;
  const pts_per_sim = 200;

  const padding = {top: 0, left: 0, right: 0, bottom: 0};
  const width = 450 - padding.left - padding.right;
  const height = 250 - padding.top - padding.bottom;

  const xScale = d3.scaleLinear()
          .domain([0, pts_per_sim]).range([0, width]);
  const yScale = d3.scaleLinear()
          .domain([0, 1]).range([0, height]);


  const data = random_data(num_sims, pts_per_sim);

  const ctx = document.getElementById('chart').getContext('2d');   
  ctx.strokeStyle = 'rgba(31,106,102,.2)';
  ctx.lineWidth = .2;

  let timestamp_start;
  let last = {sim_ind:0, pt_ind:0};
  function animationFn(timestamp){
    if (timestamp_start === undefined) {
      timestamp_start = timestamp;
    }
    const elapsed_ms = timestamp - timestamp_start;

    const position = getPosition(elapsed_ms, num_sims, pts_per_sim);

    ctx.beginPath();
    for (let sim_ind=last.sim_ind; sim_ind<= Math.min(position.sim_ind, data.length-1); sim_ind++){
      let pts = data[sim_ind].pts;

      // off by one todo:
      for (let pt_ind=last.pt_ind; pt_ind<=Math.min(position.pt_ind, pts.length-2); pt_ind++){
        let x = xScale(pt_ind);
        let y = yScale(pts[pt_ind]);
        ctx.moveTo(x, y);

        a = xScale(pt_ind+1);
        b = yScale(pts[pt_ind+1]);
        ctx.lineTo(a, b);
        // console.log(x, y, a, b);
      }    
      ctx.stroke();
    }

    const allowed_ms = 5000; // todo: remove
    if (elapsed_ms < allowed_ms) { 
      last = position; 
      window.requestAnimationFrame(animationFn);
    }
  }
  window.requestAnimationFrame(animationFn);
}
start_animation();


function static_histogram(){
  const num_sims = 100;
  const pts_per_sim = 50;

  const padding = {top: 0, left: 0, right: 0, bottom: 0};
  const width = 450 - padding.left - padding.right;
  const height = 250 - padding.top - padding.bottom;


  // todo: gotta use the same data so we 
  const data = random_data(num_sims, pts_per_sim);

  // make the histogram bins using d3

  const values = [];
  data.forEach(function(datum){
    values.push(datum.european);
    values.push(datum.asian);
  });
  const hist = d3.histogram()(values);

      // .value(function(d) { return d.price; })   // I need to give the vector of value
      // .domain(x.domain())  // then the domain of the graphic
      // .thresholds(x.ticks(70)); // then the numbers of bins

  const num_bins = hist.length;
  const max_in_a_bin = _.max(hist.map(x => x.length));

  const xScale = d3.scaleLinear()
          .domain([0, num_bins]).range([0, width]);
  const yScale = d3.scaleLinear()
          .domain([0, max_in_a_bin]).range([height, 0]);


  const ctx = document.getElementById('histogram').getContext('2d');   
  ctx.strokeStyle = 'rgba(31,106,102,.4)';
  ctx.lineWidth = .2;

  ctx.beginPath();
  for (let bin_id=0; bin_id<num_bins; bin_id++){
    let bin = hist[bin_id];
    for (let i=0; i<bin.length; i++){
      let x1 = xScale(bin_id);
      let x2 = xScale(bin_id+1);
      let y = yScale(i);
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
    }    
    ctx.stroke();
  }
}
static_histogram();



// function static_chart(){
//   const num_sims = 10;
//   const pts_per_sim = 50;

//   const padding = {top: 0, left: 0, right: 0, bottom: 0};
//   const width = 450 - padding.left - padding.right;
//   const height = 250 - padding.top - padding.bottom;

//   const xScale = d3.scaleLinear()
//           .domain([0, pts_per_sim]).range([0, width]);
//   const yScale = d3.scaleLinear()
//           .domain([0, 1]).range([0, height]);

//   const data = random_data(num_sims, pts_per_sim);

//   const ctx = document.getElementById('chart').getContext('2d');   
//   ctx.strokeStyle = 'rgba(31,106,102,.2)';
//   ctx.lineWidth = .2;

//   ctx.beginPath();
//   for (let j=0; j<data.length; j++){
//     let pts = data[j].pts;
//     for (let i=0; i<pts.length-1; i++){
//       let x = xScale(i);
//       let y = yScale(pts[i]);
//       ctx.moveTo(x, y);

//       x = xScale(i+1);
//       y = yScale(pts[i+1]);
//       ctx.lineTo(x, y);
//     }    
//     ctx.stroke();
//   }


// }
// static_chart();

// const element = document.getElementById('some-element-you-want-to-animate');
// let start, previousTimeStamp;
// let done = false

// function step(timestamp) {
//   if (start === undefined) {
//     start = timestamp;
//     }
//   const elapsed = timestamp - start;

//   if (previousTimeStamp !== timestamp) {
//     // Math.min() is used here to make sure the element stops at exactly 200px
//     const count = Math.min(0.1 * elapsed, 200);
//     element.style.transform = 'translateX(' + count + 'px)';
//     if (count === 200) done = true;
//   }

//   if (elapsed < 2000) { // Stop the animation after 2 seconds
//     previousTimeStamp = timestamp
//     !done && window.requestAnimationFrame(step);
//   }
// }

// window.requestAnimationFrame(step);

// function chart(){
//   padding = {top: 0, left: 0, right: 0, bottom: 0};
//   width = 450 - padding.left - padding.right;
//   height = 250 - padding.top - padding.bottom;
//   const ctx = document.getElementById('chart').getContext('2d');

//   ctx.translate(75, 75);
//   ctx.scale(0.4, 0.4);
//   ctx.rotate(-Math.PI / 2);

//   ctx.strokeStyle = 'black';
//   ctx.fillStyle = 'white';
//   ctx.lineWidth = 8;
//   ctx.lineCap = 'round';

//   const now = new Date();
//   const sec = now.getSeconds();
//   const min = now.getMinutes();
//   const hr  = now.getHours() % 12;

//   // Write seconds
//   ctx.save();
//   ctx.rotate(sec * Math.PI / 30);
//   ctx.strokeStyle = '#D40000';
//   ctx.fillStyle = '#D40000';
//   ctx.lineWidth = 6;
//   ctx.beginPath();
//   ctx.moveTo(-30, 0);
//   ctx.lineTo(83, 0);
//   ctx.stroke();
//   ctx.beginPath();
//   ctx.arc(0, 0, 10, 0, Math.PI * 2, true);
//   ctx.fill();
//   ctx.beginPath();
//   ctx.arc(95, 0, 10, 0, Math.PI * 2, true);
//   ctx.stroke();
//   ctx.fillStyle = 'rgba(0, 0, 0, 0)';
//   ctx.arc(0, 0, 3, 0, Math.PI * 2, true);
//   ctx.fill();
//   ctx.restore();

//   window.requestAnimationFrame(chart);
// }
// window.requestAnimationFrame(chart);


// function clock() {
//   const now = new Date();
//   const ctx = document.getElementById('canvas').getContext('2d');
//   ctx.save();
//   ctx.clearRect(0, 0, 150, 150);
//   ctx.translate(75, 75);
//   ctx.scale(0.4, 0.4);
//   ctx.rotate(-Math.PI / 2);
//   ctx.strokeStyle = 'black';
//   ctx.fillStyle = 'white';
//   ctx.lineWidth = 8;
//   ctx.lineCap = 'round';

//   // Hour marks
//   ctx.save();
//   for (let i = 0; i < 12; i++) {
//     ctx.beginPath();
//     ctx.rotate(Math.PI / 6);
//     ctx.moveTo(100, 0);
//     ctx.lineTo(120, 0);
//     ctx.stroke();
//   }
//   ctx.restore();

//   // Minute marks
//   ctx.save();
//   ctx.lineWidth = 5;
//   for (i = 0; i < 60; i++) {
//     if (i % 5!= 0) {
//       ctx.beginPath();
//       ctx.moveTo(117, 0);
//       ctx.lineTo(120, 0);
//       ctx.stroke();
//     }
//     ctx.rotate(Math.PI / 30);
//   }
//   ctx.restore();

//   const sec = now.getSeconds();
//   const min = now.getMinutes();
//   const hr  = now.getHours() % 12;

//   ctx.fillStyle = 'black';

//   // write Hours
//   ctx.save();
//   ctx.rotate(hr * (Math.PI / 6) + (Math.PI / 360) * min + (Math.PI / 21600) *sec);
//   ctx.lineWidth = 14;
//   ctx.beginPath();
//   ctx.moveTo(-20, 0);
//   ctx.lineTo(80, 0);
//   ctx.stroke();
//   ctx.restore();

//   // write Minutes
//   ctx.save();
//   ctx.rotate((Math.PI / 30) * min + (Math.PI / 1800) * sec);
//   ctx.lineWidth = 10;
//   ctx.beginPath();
//   ctx.moveTo(-28, 0);
//   ctx.lineTo(112, 0);
//   ctx.stroke();
//   ctx.restore();

//   // Write seconds
//   ctx.save();
//   ctx.rotate(sec * Math.PI / 30);
//   ctx.strokeStyle = '#D40000';
//   ctx.fillStyle = '#D40000';
//   ctx.lineWidth = 6;
//   ctx.beginPath();
//   ctx.moveTo(-30, 0);
//   ctx.lineTo(83, 0);
//   ctx.stroke();
//   ctx.beginPath();
//   ctx.arc(0, 0, 10, 0, Math.PI * 2, true);
//   ctx.fill();
//   ctx.beginPath();
//   ctx.arc(95, 0, 10, 0, Math.PI * 2, true);
//   ctx.stroke();
//   ctx.fillStyle = 'rgba(0, 0, 0, 0)';
//   ctx.arc(0, 0, 3, 0, Math.PI * 2, true);
//   ctx.fill();
//   ctx.restore();

//   ctx.beginPath();
//   ctx.lineWidth = 14;
//   ctx.strokeStyle = '#325FA2';
//   ctx.arc(0, 0, 142, 0, Math.PI * 2, true);
//   ctx.stroke();

//   ctx.restore();

//   window.requestAnimationFrame(clock);
// }

// window.requestAnimationFrame(clock);

</script>